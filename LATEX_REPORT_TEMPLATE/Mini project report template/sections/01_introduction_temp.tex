
\section{Introduction}
\label{chap:introduction}

This report delves into the analysis of a complex and intriguing LAN-based multiplayer adaptation of the classic game Doom 64, named "Doom64 Online." The project has been selected for its intricate blend of retro gaming elements and advanced networking concepts. This fusion presents an opportunity to explore and understand the challenges and intricacies involved in modernizing a classic game for contemporary networked multiplayer environments.

\subsection{Reason for Selection}

The decision to analyze this project is driven by the following:
\begin{itemize}
    \item \textbf{Technical Insights:} The use of Python and Pygame \cite{pygame} offers a unique opportunity to apply networking principles in a game development context, providing insights into real-time data transfer, concurrency handling, and network efficiency in multiplayer games.
    \item \textbf{Educational Value:} It serves as an educational tool for understanding the application of socket programming, UDP communication, and game loop management in a Python-based environment.
    \item \textbf{Personal Interest:} The choice is also influenced by a personal fascination with the technical aspects of game development and the unique challenges posed by networked multiplayer game programming.
    \item \textbf{Multiplayer Game Development:} The project offers an opportunity to learn how AAA multiplayer games are implemented at a lower level by building it from scratch, instead of merely following pre-established frameworks or methodologies. This approach allows for a deeper understanding of the underlying mechanics and challenges involved in high-end game development.
\end{itemize}

\subsection{Analysis Focus and Hypotheses}

The analysis revolves around several key areas:

\begin{itemize}
    \item \textbf{Networking Implementation:} How does the project handle real-time communication and data synchronization between the server and multiple clients?
    \item \textbf{Concurrency Management:} How are multiple concurrent player interactions managed without compromising game performance?
    \item \textbf{Gameplay Integrity:} How does the networked environment affect gameplay, and what measures are in place to maintain game integrity and responsiveness?
\end{itemize}

The hypothesis is that the Doom64 Online project effectively utilizes Python's networking capabilities to create a seamless multiplayer experience, overcoming the challenges of latency and data consistency.

For more information on referencing in LaTeX, please visit: \url{https://www.his.se/en/library/write-and-cite/referencing/}


\subsection{Research questions/hypotheses}
\label{sec:question}

The following research questions and hypotheses are formulated to guide the analysis of the Doom64 Online project and will be pivotal in user evaluation:

\begin{enumerate}
    
    \item \textbf{Concurrency and Multiplayer Interaction:} How are concurrent actions from multiple players managed and synchronized by the server? Does the game maintain consistency in the shared game world across all clients?
    
    \item \textbf{Scalability of the Game Architecture:} Can the network architecture of Doom64 Online efficiently scale to accommodate an increasing number of players without degrading performance or gameplay experience?
    
    \item \textbf{Gameplay Mechanics and Network Dependence:} To what extent do the game's mechanics rely on network performance? Are there fallback mechanisms to handle network instability?
    
    \item \textbf{Implementation Challenges:} What are the primary challenges faced during the implementation of networked multiplayer features in Doom64 Online, and how were they addressed?
    
    \item \textbf{Comparison with AAA Game Standards:} How does the networking implementation in Doom64 Online compare with standard practices in AAA multiplayer games? Are there any noticeable differences in approaches to network management, data handling, and player synchronization?
    
\end{enumerate}
\section{Background}
\label{chap:background}


The challenge of efficient data sharing in multiplayer gaming environments is a well-explored domain, with numerous solutions proposed over the years. Fundamentally, this challenge revolves around the rapid and reliable transmission of game-related data such as player positions, health status, and various state variables. Two primary approaches have emerged as the most prevalent in addressing this problem: peer-to-peer (P2P) and client-server architectures.

In the peer-to-peer model, as detailed in existing literature \cite{peertopeer}, each player directly connects with other players, facilitating a decentralized exchange of data. While this approach enables direct data sharing among participants, it lacks a centralized validation mechanism, potentially leading to issues such as cheating and data inconsistency.

Conversely, the client-server model \cite{clientserver} centralizes data exchange, where all players connect to a dedicated server. This server acts as an authoritative source, validating and relaying data among players. This method enhances security and data integrity, as the server verifies all shared information before dissemination. However, its major drawback is the dependency on a single point of failure; server downtime directly impacts all connected players, rendering the game non-functional.

This project aims to delve into the intricacies of implementing a robust client-server communication system for a specific multiplayer game. We explore both UDP and TCP protocols to determine their suitability in different gaming scenarios, comparing their efficiency in handling real-time data exchange. Additionally, we evaluate various data packet formats, ranging from binary (like Pickle) to text-based (such as JSON), to ascertain the most effective method for data serialization and transmission.

To address concurrency, a critical aspect of multiplayer gaming, we investigate several programming constructs and system calls. These include traditional methods like os.fork, as well as more modern approaches such as the multithreading and multiprocessing libraries in Python. Each method is tested for its ability to handle simultaneous requests and data processing, ensuring that the game maintains consistent performance and responsiveness under varying load conditions.
% \newline
\hrule
% \newline
How do you plan to address the problem and answer your hypotheses? Review and describe the related literature. It is encouraged to make use of the seminar papers already provided, if applicable. What are the previous researchesâ€™ questions, results, and solutions and how do they relate to your problem? For example, if your project is about analyzing predictions of the effects of global warming, how have others addressed this problem? Which analysis techniques have they used for their particular data and why? That is, can the related research found help you in your work on your data, analysis, visualization, and evaluation?


\section{Data}
\label{chap:data}

The dataset for this project primarily revolves around the core assets and gameplay mechanics obtained from the open-source repository for a basic implementation of a DOOM-style game, accessible at \cite{doom-repo}. This foundational codebase serves as the starting point for the implementation of our networked multiplayer adaptation, "Doom64 Online."

\subsection{Data Preparation}
\label{sec:data preparation}

The adaptation of the base game into a multiplayer environment necessitated the development of a robust application layer from scratch. A critical aspect of this development was the design and implementation of custom communication message classes. These classes are instrumental in managing the data flow between the game clients and the server, ensuring efficient and reliable data exchange.

For data serialization and transmission, we opted for JSON, owing to its widespread use and ease of integration with Python. The message classes were designed to encapsulate various types of game-related information, such as player positions, game state updates, and login requests/responses. The following code snippet provides an overview of these classes:

\begin{lstlisting}[language=Python]





Code snippet for custom message classes

from settings import *
import json




class PacketClass:
    type = None
    msg = None
    def   init  (self,type=None,msg=None):
        self.type=type
        self.msg=msg

class LoginResMsg:
	x=0
	y=0
	id=None
	def   init  (self,x,y,id):
		self.x=x
		self.y=y
		self.id=id
	def getJson(self):
		return json.dumps(self.  dict  )

# this is an example implementation for one of the message class used for login
# (Note: For complete code, refer to the project repository)

\end{lstlisting}

These classes are a cornerstone in the architecture of Doom64 Online, facilitating the translation of game actions into network messages and vice versa. The JSON conversion capability integrated within these classes ensures a standardized format for data exchange, contributing to the overall consistency and reliability of the multiplayer experience.

\subsection{Significance of Data Preparation}
The design and implementation of these message classes were pivotal in achieving several project objectives:
\begin{itemize}
\item \textbf{Efficient Data Handling:} By using JSON for data serialization, the project benefits from a lightweight and easily parsable data format, crucial for real-time gaming scenarios.
\item \textbf{Scalability:} The modular nature of these classes allows for easy expansion and modification, essential for accommodating future enhancements or changes in game mechanics.
\item \textbf{Network Transparency:} Custom message classes provide a clear and structured way to handle various types of network communication, enhancing the maintainability and readability of the code.
\end{itemize}

In conclusion, the careful preparation and design of the data handling mechanisms in Doom64 Online play a critical role in ensuring the seamless operation and scalability of the game's multiplayer functionality.

% \section{Data}
% \label{chap:data}
% Briefly describe the dataset and the parameters that will be important for you in order to answer your questions/hypotheses. Indicate the source. If available online, providing a URL link helps the readers.

% \subsection{Data preparation}
% \label{sec:data}
% Describe what you did in order to use the data for analysis.
\section{Approach}
\label{chap:approach}

This section outlines the approach taken in developing "Doom64 Online," focusing on the server architecture, network communication, and handling of game state.

\subsection{Overview of Server Architecture}
The server is designed to manage all player data within a Game State class. This class stores information such as player positions, health, and other game-related states. Custom message classes, which are serialized into JSON, facilitate network communication.

\subsubsection{Server's Role}

    Listening for client connections on a specified port.
    Allocating a unique thread and socket for each client for dedicated communication.
    Maintaining a shared game State class across threads for consistent game state updates.
    Periodically sending updated game state information to all clients.
    Processing incoming player data from clients to update the server's game state.

\subsection{TCP Server Implementation}
Initially, the TCP protocol was used for its easy implementation as the features for assigning new ports for when ever a new client is connected are a builtin function for TCP.

\subsubsection{TCPServer Class}
The TCPServer class handles client connections and communication. It includes methods for starting the server, accepting client connections, and handling client data.

\paragraph{Start Method}

    Listens for incoming client connections.
    On a new connection, starts a new thread (handle client) for each client thorugh a unique port assigned to each.

\paragraph{Handle Client Method}

    Receives data from the client.
    Updates the game state based on received data.
    Handles any exceptions and disconnects.

\subsubsection{TCP Implementation Details}

    The server uses a ServerCon class for base connections.
    A MultiCliCon class is used for managing individual client connections.
    The game state is updated in real-time based on client inputs.

\subsection{Transition to UDP}
Using this implementation of the server there was high latency and wait time when ever the number of players increased as every response cannot be unacknowledege Due to TCP's higher latency, we shifted to UDP for better performance.

\subsubsection{UDPServer Class}
The UDPServer class utilizes UDP for faster communication, sacrificing some reliability for reduced latency.

\paragraph{UDP Server Functionality}

    This version of the server partially implements the TCP server functionality that is the server waits for clients to send a connection request and a unique port is assigned to each client for dedicated communication and new thread is created for conncurent communication.

\paragraph{Client-Server Communication}

    All the communication between the client and server is done thorugh custom messages which encode the messages into json strigs and send over the network. The code snippet for the custom classes are  :
    \begin{lstlisting}[language=Python]

class PacketClass:
    type = None
    msg = None

    def __init__(self,type=None,msg=None):
    

class LoginResMsg:
    type = None
    msg = None

    def __init__(self,x,y,id):
        
    def getJson(self):
        return json.dumps(self.__dict__)



class JsonPacket:
    type = None
    msg = None
    def __init__(self,type=None,msg=None):
        if type :
            self.type=type
            if self.type!=LOGIN_REQ and self.type != UDP_CON_REQ:
                self.msg=json.loads(msg)
            else:
                self.msg = msg

    def udpConnReq(self):
        self.type = UDP_CON_REQ
        self.msg = None
        return self.getJson()

    def udpConnRes(self,socket):
        self.type = UDP_CON_RES
        self.msg = str(socket)
        return self.getJson()

    def loginReq(self,username):
        self.type=LOGIN_REQ
        self.msg=username
        return self.getJson()

    def loginRes(self,spawn):
        self.type=LOGIN_RES
        self.msg=spawn.getJson()
        return self.getJson()

    def playerUpdate(self,player):
        self.type=PLAYER_UPDATE
        self.msg=player.getJson()
        return self.getJson()

    def gameStateUpdate(self,game_state):
        self.type=GAME_STATE
        self.msg=game_state.getJson()
        return self.getJson()

    def getJson(self):
        return json.dumps(self.__dict__)






class DataPlayer:
    position=[0,0]
    yaw=0
    shoot=False
    health = None
    shotWho=None
    def __init__(self,position=[0,0],yaw=0,shoot=False,health=None,shotWho=None):
        self.position=position
        self.yaw=yaw
        self.shoot=shoot
        self.health=health
        self.shotWho=shotWho
    def update(self,position=[0,0],yaw=0,shoot=False):
        self.position=position
        self.yaw=yaw
        self.shoot=shoot
    def show(self):
        print(self.__dict__)
    def __str__(self):
        return str(self.__dict__)
    def getJson(self):
        # print(self.__dict__)
        return json.dumps(self.__dict__)

    \end{lstlisting}

\subsection{Game State Management}
The game state is updates according to the data recieved from each client. As all the game logic is implemented on the client side and the server only acts as a medium for communication between the clients. To explain this is a better way lets take an example. lets say There is a player A and player B. Player A shoots player B. This action will be recognised by the clients code and this will update the server of this event and the server will notify player B to reduce its health by a certain amount. 

\subsubsection{Game State Class Functions}

    Stores and updates player data.
    Provides methods to serialize the game state into JSON for network transmission.
    Implements logic for game-specific actions (like ray casting for player visibility).

    code for the same is given below : 
    \begin{lstlisting}[language=Python]

    
class Game_State:
    running=False
    players={}
    # score=0
    map_obj=None

    def __init__(self,running=False,players={},map_obj=None):
        self.running=running
        self.players=players
        self.map_obj=map_obj

    def get_players_json(self,id):
        temp={}
        for i , player in self.players.items():
            temp[str(i)]=str(player.__dict__)
        temp[str(-1)]=str(id)
        return json.dumps(temp,indent=1)
        
    def show(self,id =None):
        print("Game State: ###########\n")
        if id:
            for i, player in self.players.items():
                if i != id:
                    print(f"Player {i}: {player}") 
        else:
            for i, player in self.players.items():
                
                print(f"Player {i}: {player}")
        print("############\n\n")
        # for i in self.players:
        # 	i.show()

    def getJson(self):
        return json.dumps(self.players)
        \end{lstlisting}
\subsection{Pseudocode for Server Flow}
\begin{verbatim}
    1. UDPMultiCliCon Class:
    - Create a UDP socket and bind it to a specified address and port.
    - Include methods to:
      - Receive data from clients.
      - Accept login requests and allocate spawn positions.
      - Update the game state and send it to clients.
 
 2. UDPServerCon Class:
    - Create a UDP socket for the main server connection.
    - Include methods to:
      - Accept incoming messages.
      - Send connection information to clients (like assigned ports).
 
 3. UDPServer Class:
    - Initialize game state and a dictionary to manage client handlers.
    - Assign new ports for clients to maintain separate communication channels.
    - In the `start` method:
      - Continuously listen for new connections.
      - For each new connection, assign a port and start a new thread for handling the client.
      - Send the client their unique communication port.
    - In the `handle_client` method:
      - Manage communication with individual clients.
      - Update the game state based on client actions.
      - Handle client disconnections and remove them from the game state.
 
 4. Main Server Execution:
    - Define the server host and port.
    - Create an instance of the UDPServer class.
    - Call the `start` method on the server instance to begin listening for and handling client connections.
\end{verbatim}

complete code will be provided at the end.

CLient side implementation : 

There is a main connection class used for communication to the server. which formats all the data using the message classes mentioned above. The code for the same is given below :

\begin{lstlisting}[language=Python]

    class UDPCon:
        s=None
        sendMsg=None
        revMsg=None
        cliAddr = None
        port = None
        host=HOST
        def __init__(self,host=None,port=None):
            self.s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
            self.s.settimeout(0.5)
            if host:
                self.host=host
        def accMsg(self):
            self.revMsg , self.cliAddr = self.s.recvfrom(RECIEVE_BUFFER_SIZE)
            self.revMsg = json.loads(self.revMsg)
            print("DATA REC "+self.recvMsg["type"],self.recvMsg["msg"])
            self.recvMsg=JsonPacket(self.recvMsg["type"],self.recvMsg["msg"])
            if self.recvMsg.type != UDP_CON_REQ:
                return None,None
            return self.recvMsg,self.cliAddr
    
        def sendConnMsg(self):
            self.sendMsg=JsonPacket()
            self.sendMsg=self.sendMsg.udpConnReq()
            sent =False
            while not sent:
                try:
                    self.s.sendto(self.sendMsg.encode("utf-8"), (self.host,PORT))
                    self.revMsg = self.s.recvfrom(RECIEVE_BUFFER_SIZE)[0]
                    sent = True
                except Exception as e:
    
                    print(e)
                    sent = False
                    continue
            self.revMsg = json.loads(self.revMsg)
            print("DATA REC "+self.revMsg["type"],self.revMsg["msg"])
            return int(self.revMsg["msg"])
            # return 7001
    
        def login(self,username):
            
            print(self.host,self.port)
    
            self.sendMsg=JsonPacket()
            self.sendMsg=self.sendMsg.loginReq(username)
            sent = False
            while not sent:
                try:
            # sleep(0.5)
                    self.s.sendto(self.sendMsg.encode("utf-8"), (self.host,self.port))
                # except timeout of socket
                    
            
                    self.revMsg = self.s.recvfrom(RECIEVE_BUFFER_SIZE)[0]
                    sent = True
                except Exception as e:
                    print(e)
                    sent = False
    
    
            print(self.revMsg)
            self.revMsg = json.loads(self.revMsg)
            self.revMsg=JsonPacket(self.revMsg["type"],self.revMsg["msg"])
            # print([int(self.revMsg.msg['x']),int(self.revMsg.msg['y']),int(self.revMsg.msg['id'])])
            return [int(self.revMsg.msg["x"]),int(self.revMsg.msg["y"]),int(self.revMsg.msg["id"])]
            
        def playerUpdate(self,player):
            self.sendMsg=JsonPacket()
            self.sendMsg=self.sendMsg.playerUpdate(player)
    
            sent = False
            while not sent:
                try:
    
                    self.s.sendto(self.sendMsg.encode("utf-8"),(self.host,self.port))
                    self.revMsg = self.s.recvfrom(RECIEVE_BUFFER_SIZE)[0]
                    sent = True
                except Exception as e:
                    print(e)
                    sent = False
                    continue
            
    
    
            print(self.revMsg)
            self.revMsg = json.loads(self.revMsg)
            self.revMsg = JsonPacket(self.revMsg["type"], self.revMsg["msg"])
            return self.revMsg
\end{lstlisting}

the client is Initialized and connected by sending a connection format message to the server

\begin{lstlisting}[language=Python]
    connector = UDPCon(host=host)
    porttemp = connector.sendConnMsg()
\end{lstlisting}

After connection to the server the player logs into the game to recieve its initial spawn location and id as mentioned in the UDPCon class.

\begin{lstlisting}[language=Python]
    spawn_location= connector.login(username)
\end{lstlisting}


After that for each game cycle the playerUpdate  method in the connector is called and player updates are sent to the server.

\begin{lstlisting}[language=Python]
   
    obj=DataPlayer([self.player.pos],self.player.angle,self.player.shot,self.player.health,self.player.shotWho)

    game_state_res=self.connector.playerUpdate(obj)
    
\end{lstlisting}
    
The player update contains the following data : 
\begin{itemize}
    \item new position
    \item new angle
    \item if the player has shot or not
    \item the health of the player
    \item the id of the player who has been shot if shot
\end{itemize}


\subsection{server finder}
The server finder is a simple script that is used to find the server on the local network. It uses the UDP protocol to broadcast a message on the local network on a specific port and the server responds to the message with its ip address and port. 

This is done by first finding all the active interfaces on the local network using ' nmap ' command.

\begin{lstlisting}[language=Python]

def find_all_ips():
    hostname = socket.gethostname()
    IPAddr = socket.gethostbyname(hostname)


    print("Your Computer Name is:" + hostname)
    print("Your Computer IP Address is:" + IPAddr)
    secs=IPAddr.split(".")
    netId= ""
    for i in range(len(secs)-1):
        netId+= secs[i]+"."
    netId+="0"
    print(netId)

    os.system("nmap -n -sn "+netId+"/24 -oG - | awk '/Up$/{print $2}' > ips.txt")
\end{lstlisting}

after this we use the stored ip addresses to broadcast a server finder message and if the server responds with the correct message we store the ip address and port of the server.

\begin{lstlisting}[language=Python] 

def find_server():
    file1 = open('ips.txt', 'r')
    Lines = file1.readlines()

    count = 0

    s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
    s.settimeout(FINDER_TIMEOUT)
    line =None
    # Strips the newline character
    for line in Lines:
        try:
        # print("-"+line[:-1]+"-")
            s.sendto("server?".encode("utf-8"), (line[:-1],SERVER_FINDER_PORT))
            revMsg , cliAddr = s.recvfrom(RECIEVE_BUFFER_SIZE)
            if revMsg:
                print("request -> "+line+ "\nresponse -> " +revMsg.decode())
                break
            # os.system("ping "+line+" "+str(SERVER_FINDER_PORT))
            count += 1
        except Exception as e:
            print(e)
            continue
    if line:
        return line[:-1]
    else:
        return HOST
\end{lstlisting}


and that completes the network implementation of a multiplayer first person shooter

    Describe the techniques that you will use for managing and analyzing your data and the tool(s) that you will use for data management/data analysis and evaluation. Motivate why you have chosen a certain method over others and describe how you plan to evaluate your solution. This section should give a detailed account of what you did in order to answer your questions.
    
    \section{Results}
    \label{chap:results}
    Describe your final data analysis results and everything that you discovered on the way the put you forward and you think is worth describing here. Elaborate on the significance of your findings/results and convey your thoughts. 
    
    \section{Discussion}
\label{chap:discussion}
What do the results mean (their significance and to whom) and how do they answer your research questions/hypotheses? From the evaluation and validation of the tool, what can you conclude? 

\subsection{Limitations and Challenges}
\label{sec:limitation}
What could have been investigated if given more time? What have been difficult when solving the problem and getting answers for your research questions/hypotheses?

\section{Conclusion}
\label{chap:conclusion}
Write the conclusion. What did you gain from the project assignment? Briefly explain your questions/hypotheses, findings, and meaningful discussion points in relation to the data collection, data management, data analysis, visualization and interaction concepts, and evaluation of your tool.
What additional investigations need to be performed (or what is the limitation) in order to say that your solution is a good one for the problem? 

\section{Reflections on own work}
\label{chap:reflection}
\begin{itemize}
    \item Describe how you decided to scope (and/or re-scope) your problem formulation during the work, and given the data you had access to.
    \item Describe how you searched for knowledge on how to scope the DS question you wanted to answer 
    \item understand how to implement, test, and validate your results. 
    \item Which sources helped you to get progress and how?
    \item What would you have done differently if you were to start over again, for understanding the problem faster and for understanding what could be done with the data you had access to?
    \item What else is there that you would have changed about this assignment?
\end{itemize}

\newpage